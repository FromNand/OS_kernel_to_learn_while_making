##### カーネルのオフセット(セクタ単位)とサイズ(セクタ単位)が入っているアドレス(LBA方式) #####
##### このIPLではdsを0x07c0に初期化しているので、これらのデータにアクセスする機械語のアドレスには0x7c00だけ加算される #####
.equ	KERNEL_IMAGE_OFFSET, 0x01f6
.equ	KERNEL_IMAGE_SIZE  , 0x01fa

##### 16bitモード用の機械語を生成する #####
.code16

##### .textにプログラムを配置する #####
.text

##### プログラムの実行に最低限必要な初期化を行う #####
	sti					# biosがstiし忘れていても大丈夫なように。
	ljmpw	$0x07c0, $entry			# IPLのプログラム部分のVMAを0にするために、cs=0x07c0とする。
entry:
	movw	%cs, %ax			# セグメントレジスタを即値で初期化する機械語は存在しないので、axに入れてからセグメントレジスタを初期化している。
	movw	%ax, %ds			# IPLのデータ部分のVMAを0にするために、ds=0x07c0とする。
	movw	%ax, %es			# 8086ではセグメントレジスタはcs,ds,es,ssの4つしかなかった。リアルモードでもこの4つのレジスタを初期化。
	xorw	%ax, %ax			# ax = 0。
	movw	%ax, %ss			# ssのベースは0。オフセットのspでスタックトップを決める。
	movw	$0x7c00, %sp			# スタックポインタはbiosがIPLをロードする0x7c00より下の部分にとりあえず決める。

##### dlの値が変わってしまう前に、起動デバイスがHDD系であるかどうかをチェックする #####
	movb	%dl, (drv)			# dlには起動時にドライブ番号が入っている。
	cmpb	$0x80, %dl			# FDDの場合は0x00, 0x01, 0x02...。HDDの場合は0x80, 0x81, 0x82...。
	jb	unsupported			# 起動デバイスがHDD系でない場合は、このIPLのサポート外。

##### IPLの処理中であることをユーザに文字列表示で知らせる #####
	leaw	(bootmsg), %si			# 文字列の先頭アドレスをsiにセットする。
boot_msg_loop:
	lodsb					# alに文字列から一文字分のアスキーコードを取得し、siに1加算する。
	cmpb	$0, %al				# それがなる文字(0)だったら...
	je	get_kernel_info			# IPL本来の処理に移行する。
	movb	$0x0e, %ah			# 一文字表示関数はah=0x0eでint 0x10。
	movw	$0, %bx				# bxはグラフィックモードの設定みたいだけど、よくわからない。
	int	$0x10				# BIOS呼び出し。
	jmp	boot_msg_loop			# 次の文字を読むためにループの先頭に戻る。

##### リンカスクリプト、もしくはパーティション作成ソフトによって書き込まれたカーネルの情報を取得し、利用する #####
get_kernel_info:
	movl	(KERNEL_IMAGE_OFFSET), %eax	# 起動ディスクの中でのカーネルのオフセットを取得する。(ただし、IPLの次のセクタからをカーネルと仮定している。)
	movl	%eax, (lba0)			# lba方式でディスクからの読み出しを行うので、その情報を正しい情報で書き換える。
	movw	(KERNEL_IMAGE_SIZE), %bx	# カーネル(IPLを除く)サイズを取得し、bxに格納する。

##### BIOSから使用してもよいメモリの範囲を取得する #####
check_low_memory:
	int	$0x12				# リアルモードにおいてOS開発者が利用できるメモリをaxに取得する。(ただし、本当のサイズはここで取得した値に1024を掛ける必要がある。)
	shlw	$1, %ax				# 上で取得した値に2を掛けることでセクタ単位に変換できる。(int 0x12で取得した値は1024分の1。この値に2を掛けると512分の1になるから。)
	subw	$0x40, %ax			# カーネルは0x8000から展開するが、ここまでのメモリはメモリサイズから引いておく必要がある。(0x8000/0x200=0x40)
	cmpw	%ax, %bx			# リアルモードで使用できるメモリサイズとカーネルのサイズを比較する。(セクタ単位)
	ja	error				# もし、カーネルのサイズがリアルモードで使用できるメモリサイズよりも大きいならばエラー。
	addw	$15, %bx			# カーネルイメージのサイズ(セクタ単位)を16の倍数に切り上げる。
	shrw	$4, %bx				# 読み込み処理高速化のために16セクタ単位で読み込みを行う。なので、サイズを16で割っておく。
	movw	%bx, (sec_num)			# カーネルが適切なサイズならば、読み込むセクタサイズを記憶する変数に書き込んでおく。

##### 拡張INT0x13命令に対応しているかどうかのチェック #####
check_ex_int13:
	movb	$0x41, %ah			# ah=0x41 →  拡張INT0x13命令に対応しているかを調べる。
	movw	$0x55aa, %bx			# bx=0x55aaにしておかないといけない。
	int	$0x13				# BIOS関数呼び出し。
	jc	unsupported			# CF == 1      : 拡張INT0x13命令は対応していないのでエラー。

	cmpw	$0xaa55, %bx			# BX == 0xaa55 : 拡張IN13Hはインストールされている。
	jne	unsupported			# bxが0xaa55でないならばエラー。

	test	$0x01, %cl			# CL.bit0 == 1 : 拡張ディスクアクセスをサポートしている。
	jz	unsupported			# CL.bit0が1でないならばエラー。

##### HDDのセクタを順番に読んでいって、メモリ上に展開する処理(LBA方式) #####
disk_read:
	xorb	%cl, %cl			# clは現在のセクタを何回読み込もうとしたのかという情報を記憶する。
disk_read_retry:
	movb	$0x42, %ah			# 拡張ディスクリードのファンクション番号は0x42。
	movb	(drv), %dl			# dlには読み込み元のディスク番号を入れる。(drv番地には起動ディスク番号が格納されている。)
	movw	$DAPS, %si			# ah=0x42, int 0x13の関数はsiにDisk Address Packetと呼ばれる構造体の先頭アドレスを入れる。
	int	$0x13				# BIOS関数呼び出し。
	jnc	disk_read_next			# CFが立っていたらエラー。JNCでジャンプするということは、HDDからメモリへのロードが一回分、無事に完了したことを意味する。

	movb	(drv), %dl			# もう一度、dlに起動ディスクの番号を取得する。
	movb	$0x00, %ah			# ファンクション番号は0x00。
	int	$0x13				# ドライブのリセットを行う。

	incb	%cl				# 現在のセクタを読み込もうとした回数+1。
	cmpb	$0x5, %cl			# 試行回数が5回以上になったとき...
	jae	error				# エラーにする。
	jmp	disk_read_retry			# 5回以下のミスはたまたま読み込めなかった可能性があるのでもう一度試してみる。(ただし、qemuではディスクイメージよりも多くのセクタを読み込むことができないらしい。)
disk_read_next:
	addl	$16, (lba0)			# 次に読み込むべきセクタを指すようにLBAをインクリメントする。
	xorl	%ebp, %ebp			# ebpは「adcw $0, %bp」「shlw $12, %bp」の部分でセグメントの計算に使用するので、0にしておく必要がある。

	movl	$addr, %ecx			# ecxはLBAの読み込み先オフセットのデータを指すポインタ。
	movl	$segm, %ebx			# ebxはLBAの読み込み先のセグメントのデータを指すポインタ。

	movw	(%ecx), %ax			# 今回、データを書き込んだアドレスをaxに入れる。
	addw	$0x2000, %ax			# 次のアドレスを指すように加算する。
	adcw	$0, %bp				# もし、0xffffよりも大きくなったら、セグメントのベースを変更するようにする。
	shlw	$12, %bp			# セグメントの値を調節する。
	addw	(segm), %bp			# もとのセグメントと足し合わせる。

	movw	%ax, (%ecx)			# addrに書き込む。
	movw	%bp, (%ebx)			# segmに書き込む。

	decw	(sec_num)			# sec_num番地には何セクタ読み込むかという情報が書き込まれているので、これは減算する。
	jnz	disk_read			# もし、まだ読み込むべきセクタがあるならば、ループの先頭に戻る。

	ljmpw	$0x1000, $0x0000		# 0x10000番地にジャンプする。

##### BIOSが対応していなかったり、エラーが出たときにはこの部分を参照する #####
unsupported:
	leaw	(msg1), %si			# エラー用メッセージを設定。
	jmp	putloop				# 文字列表示関数にジャンプ。
error:
	leaw	(msg2), %si			# エラー用メッセージを設定。
putloop:
	lodsb					# 文字列から一文字読み込む。
	cmpb	$0, %al				# それがなる文字かどうかのチェック。
	je	fin				# なる文字だったら無限ループ。
	movb	$0x0e, %ah			# ファンクション番号は0x0e。
	movw	$0, %bx				# グラフィックモードの設定みたいだけど、わからない。
	int	$0x10				# BIOS関数の呼び出し。
	jmp	putloop				# 文字列表示関数のループに戻る。
fin:
	hlt					# 楽しいHLT命令。
	jmp	fin				# HLTが割り込みとかで抜けることがある(？)から一応無限ループにしておく。

##### データを保管しておくセクション #####
.data

##### エラーメッセージ一覧 #####
bootmsg:
	.string "ipl.s: now loading....\r\n"

msg1:
	.string	"ipl.s: not supported.\r\n"   

msg2:
	.string	"ipl.s: load error.\r\n"

##### ドライブ番号を記憶しておく #####
drv:
	.byte	0x00

##### 何セクタ読み込むかを覚えておく #####
sec_num:
	.word	0x0000

##### Disk Address Packet #####
DAPS:
	.word	0x0010				# この構造体のサイズ。
	.word	0x0010				# 一度に何セクタ読み込むか。
addr:
	.word	0x0000				# 読み込み先のオフセットを指定する。
segm:
	.word	0x1000				# 読み込み先のセグメントベースを指定する。	
lba0:
	.int	0x00000000			# ディスクのどのセクタから読み込むか。
	.int	0x00000000			# より大きなディスクから読み込む場合は使用するらしい。

##### 「.byte 0x55, 0xaa」についてはipl.lsで組み込んでいるので、ipl.sでは記述する必要はない #####
